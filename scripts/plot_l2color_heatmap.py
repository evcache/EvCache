#!/usr/bin/env python3
# usage: python3 l2color_heatmap.py data/l2color-2025-01-01-12-00-00
# input files are generated by `vset -G 2` and include a header line
# `# evsets_per_color: c0 c1 ...` describing valid eviction sets per color.

import argparse
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
from matplotlib.colors import LinearSegmentedColormap
import os
import sys

DEFAULT_HALF_LIFE = 8.0

def parse_l2color_data(filename):
    colors = {}
    iterations = set()
    max_rate = 0
    wait_us = 0
    n_ways = 0
    color_counts = []
    
    with open(filename, 'r') as f:
        for line in f:
            line = line.strip()
            if line.startswith('#'):
                if 'wait_us:' in line:
                    wait_us = int(line.split(':')[1].strip())
                elif 'l3 ways:' in line:
                    n_ways = int(line.split(':')[1].strip())
                elif 'evsets_per_color:' in line:
                    counts = line.split(':', 1)[1].strip().split()
                    color_counts = [int(x) for x in counts]
                continue
            
            if not line:
                continue
            
            parts = line.split()
            if len(parts) != 3:
                continue
            
            color = int(parts[0])
            iteration = int(parts[1])
            eviction_rate = float(parts[2])
            
            if color not in colors:
                colors[color] = {}
            
            colors[color][iteration] = eviction_rate
            iterations.add(iteration)
            max_rate = max(max_rate, eviction_rate)
    
    if not color_counts:
        # infer counts from data if header missing
        max_color = max(colors.keys()) if colors else -1
        color_counts = [len(colors.get(c, {})) > 0 and 1 or 0 for c in range(max_color + 1)]

    return colors, sorted(iterations), max_rate, wait_us, n_ways, color_counts

def create_heatmap_matrix(colors, iterations):
    # matrix: rows = l2 colors, columns = iterations
    n_colors = len(colors)
    n_iterations = len(iterations)
    
    matrix = np.zeros((n_colors, n_iterations))
    
    color_list = sorted(colors.keys())
    
    for i, color in enumerate(color_list):
        for j, iteration in enumerate(iterations):
            if iteration in colors[color]:
                matrix[i, j] = colors[color][iteration]
    
    return matrix, color_list

def create_colorful_colormap():
    colors_list = [
        '#2d1b69',  # dark purple (0 evictions)
        '#512da8',  # purple
        '#673ab7',  # medium purple
        '#ffeb3b',  # bright yellow
        '#ffc107',  # yellow
        '#ff9800',  # light orange
        '#ff6f00',  # dark orange
        '#d84315'   # red
    ]
    
    return LinearSegmentedColormap.from_list('l2color', colors_list, N=256)

def create_grayscale_colormap():
    colors_list = [
        '#000000',  # black (0 evictions)
        '#1a1a1a',  # very dark gray
        '#4d4d4d',  # medium-dark gray
        '#666666',  # medium gray
        '#808080',  # gray
        '#999999',  # light-medium gray
        '#b3b3b3',  # light gray
        '#cccccc',  # very light gray
        '#e6e6e6',  # near white
        '#ffffff',  # white (high evictions)
    ]
    
    return LinearSegmentedColormap.from_list('l2color_gray', colors_list, N=256)

def two_point_asymmetric(arr, rise_weight=0.3, fall_weight=0.01, max_jump_up=0.1):
    """return 2-point asymmetric moving average using only current and previous values.
    
    args:
        arr: input array of values (0-1 normalized)
        rise_weight: weight for new value when rising (0-1, higher = more responsive to rises)
        fall_weight: weight for new value when falling (0-1, lower = stickier to falls)
        max_jump_up: maximum single-step increase (prevents sudden spikes)
    """
    if len(arr) == 0:
        return np.array([])
    
    out = np.zeros(len(arr), dtype=float)
    out[0] = arr[0]
    
    for i in range(1, len(arr)):
        current_val = arr[i]
        prev_val = out[i-1]
        
        if current_val > prev_val:
            # rising: use rise_weight and limit jump size
            target_increase = min(current_val - prev_val, max_jump_up)
            out[i] = prev_val + rise_weight * target_increase
        else:
            # falling: use fall_weight (lower = stickier)
            out[i] = prev_val + fall_weight * (current_val - prev_val)
    
    return out

def plot_l2color_heatmap(matrix, color_list, iterations, max_rate, wait_us, n_ways,
                        color_counts, output_prefix, rise_speed, fall_stickiness, max_jump, asymmetry,
                        no_colorbar=False, no_grid=False, no_line=False, heatmap_color=1):
    
    n_colors = len(color_list)
    n_iterations = len(iterations)
    
    plt.rcParams['font.family'] = 'serif'
    plt.rcParams['font.serif'] = ['Computer Modern Roman', 'Times New Roman', 'DejaVu Serif']
    plt.rcParams['mathtext.fontset'] = 'cm'
    
    row_height_factor = max(0.15, min(0.5, 20.0 / n_colors))
    fig_width = 12
    fig_height = max(6, n_colors * row_height_factor + 3)
    fig, ax = plt.subplots(figsize=(fig_width, fig_height))
    
    # select colormap based on heatmap_color parameter
    if heatmap_color == 2:
        cmap = create_grayscale_colormap()
    else:
        cmap = create_colorful_colormap()
    
    # maps eviction rates directly to a fixed 0-100% ruler so that
    # different runs remain comparable regardless of their observed range
    im = ax.imshow(matrix, cmap=cmap, aspect='auto', vmin=0, vmax=100,
                   interpolation='nearest')
    
    # x-axis; adaptive tick spacing to prevent overlap
    max_x_ticks = 15
    if n_iterations <= max_x_ticks:
        tick_interval = 1
    else:
        tick_interval = max(1, n_iterations // max_x_ticks)
        # round to intervals
        if tick_interval > 5:
            tick_interval = ((tick_interval + 4) // 5) * 10
    
    x_ticks = range(0, n_iterations, tick_interval)
    x_labels = [str(iterations[i]) for i in x_ticks]
    ax.set_xticks(x_ticks)
    ax.set_xticklabels(x_labels)
    
    # y-axis: adaptive spacing to prevent overlap
    max_y_ticks = 20
    if n_colors <= max_y_ticks:
        y_tick_indices = range(len(color_list))
        y_tick_labels = [str(c) for c in color_list]
    else:
        step = max(1, len(color_list) // max_y_ticks)
        y_tick_indices = range(0, len(color_list), step)
        y_tick_labels = [str(color_list[i]) for i in y_tick_indices]
    
    ax.set_yticks(y_tick_indices)
    ax.set_yticklabels(y_tick_labels)

    if not no_grid:
        ax.grid(True, linewidth=0.3, linestyle='--', alpha=0.5)

    # horizontal dashed lines for l2 color separation
    for i in range(len(color_list)):
        ax.axhline(y=i-0.5, color='lightgray', linestyle='--', linewidth=0.5, alpha=0.6)
        ax.axhline(y=i+0.5, color='lightgray', linestyle='--', linewidth=0.5, alpha=0.6)

    # overlay 2-point asymmetric activity lines (only if not disabled)
    if not no_line:
        for idx, c in enumerate(color_list):
            ema = two_point_asymmetric(matrix[idx] / 100.0, 
                                      rise_weight=rise_speed,           # rise responsiveness
                                      fall_weight=fall_stickiness,      # fall responsiveness
                                      max_jump_up=max_jump)             # limit sudden spikes
            y_vals = np.full(n_iterations, idx) + (ema - 0.5) * 0.8
            y_vals = np.clip(y_vals, idx - 0.4, idx + 0.4)
            ax.plot(range(n_iterations), y_vals, color='goldenrod', linestyle='-', linewidth=0.8)
    
    ax.set_xlabel(f'Iteration (wait time: {wait_us}μs per iteration)')
    ax.set_ylabel('L2 Color\n(non-canonical)', rotation=0, ha='right', va='center')
    ax.set_title('L2 Color Cache Occupancy Heatmap\nEviction Rate (%)')
    
    ax.set_ylim(-0.5, len(color_list) - 0.5)
    
    if not no_colorbar:
        cbar = plt.colorbar(im, ax=ax, shrink=0.8)
        cbar.set_label('Eviction Rate (%)')
        
        # always display a 0-100% scale on the colorbar
        cbar.set_ticks(np.linspace(0, 100, 6))
    
    plt.tight_layout()
    
    # ensure data directory exists
    os.makedirs('data', exist_ok=True)

    pdf_file = f"data/{output_prefix}.pdf"
    
    plt.savefig(pdf_file, bbox_inches='tight')
    
    print(f"Heatmap saved as: {pdf_file}")
    
    '''
    print(f"\nStatistics:")
    print(f"  L2 Colors: {len(color_list)}")
    print(f"  Iterations: {len(iterations)}")
    print(f"  Wait time: {wait_us}μs")
    print(f"  LLC ways: {n_ways}")
    print(f"  2-Point Asymmetric Algorithm:")
    print(f"  Rise weight: {rise_speed:.2f} (0=no rise, 1=instant)")
    print(f"  Fall weight: {fall_stickiness:.2f} (0=no fall, 1=instant)")
    print(f"  Max jump limit: {max_jump:.2f}")
    print(f"  Max eviction rate: {matrix.max():.1f}%")
    print(f"  Min eviction rate: {matrix.min():.1f}%")
    print(f"  Mean eviction rate: {matrix.mean():.1f}%")

    if color_counts:
        print("\nevictions per color (evsets * LLC ways):")
        for idx, cnt in enumerate(color_counts):
            print(f"  Color {idx}: {cnt * n_ways} ", end="")
        print()
    '''
    plt.close()

def main():
    parser = argparse.ArgumentParser(description='Generate L2 color heatmap from vset data')
    parser.add_argument('input_file', help='Input data file from vset -G 2')
    parser.add_argument('-o', '--output', default='',
                       help='Output file prefix (default: derived from input filename)')
    parser.add_argument('--no-colorbar', '-nc', action='store_true',
                       help='Disable colorbar in the heatmap')
    parser.add_argument('--no-grid', '-ng', action='store_true',
                       help='Disable grid lines in the heatmap')
    parser.add_argument('--no-line', '-nl', action='store_true',
                       help='Disable EWMA lines overlay')
    parser.add_argument('--rise-speed', '-rs', type=float, default=0.3,
                        help='Weight for rises (0-1, higher = faster rises, default: %(default)s)')
    parser.add_argument('--fall-stickiness', '--fs', '-fs', type=float, default=0.01,
                        help='Weight for falls (0-1, lower = stickier falls, default: %(default)s)')
    parser.add_argument('--max-jump', '-mj', type=float, default=0.15,
                        help='Maximum single-step increase to prevent sudden spikes (default: %(default)s)')
    parser.add_argument('--asymmetry', '-a', type=float, default=2.0,
                        help='Asymmetry factor: higher values make rises faster and falls stickier (default: %(default)s)')
    parser.add_argument('--heatmap-color', '-hc', type=int, choices=[1, 2], default=1,
                        help='Heatmap color scheme: 1=colorful, 2=grayscale (default: %(default)s)')
    args = parser.parse_args()
    
    if not os.path.exists(args.input_file):
        print(f"Error: Input file '{args.input_file}' not found")
        sys.exit(1)
    
    # generate output filename from input filename
    if args.output:
        output_prefix = args.output
    else:
        input_basename = os.path.basename(args.input_file)
        if input_basename.startswith('l2color-'):
            output_prefix = input_basename + '-heatmap'
        else:
            output_prefix = input_basename + '-l2color-heatmap'
    
    try:
        colors, iterations, max_rate, wait_us, n_ways, color_counts = parse_l2color_data(args.input_file)
        
        if not colors:
            print("Error: No valid data found in input file")
            sys.exit(1)
        
        print(f"{len(colors)} L2 colors and {len(iterations)} iterations")
        
        matrix, color_list = create_heatmap_matrix(colors, iterations)

        plot_l2color_heatmap(matrix, color_list, iterations, max_rate,
                           wait_us, n_ways, color_counts, output_prefix,
                           args.rise_speed, args.fall_stickiness, args.max_jump, args.asymmetry,
                           args.no_colorbar, args.no_grid, args.no_line, args.heatmap_color)
        
    except Exception as e:
        print(f"Error processing data: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
